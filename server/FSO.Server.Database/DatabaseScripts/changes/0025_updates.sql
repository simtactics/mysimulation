CREATE TABLE `fso_update_addons` (
  `addon_id` INT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(45) NOT NULL DEFAULT 'Untitled' COMMENT 'Name of the update addon.',
  `description` VARCHAR(1000) NULL,
  `addon_zip_url` VARCHAR(256) NOT NULL COMMENT 'Addon zip which is extracted on top of the client update base.',
  `server_zip_url` VARCHAR(256) NULL COMMENT 'Addon zip which is extracted on top of the server update base. (optional)',
  `date` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'Date the addon was created.',
  PRIMARY KEY (`addon_id`))
COMMENT = 'Update addons are additional resources which are combined with the base game version (from a buildbot) to create the final binary a server will update to and deploy.';

CREATE TABLE `fso_update_branch` (
  `branch_id` INT NOT NULL AUTO_INCREMENT,
  `version_format` VARCHAR(128) NOT NULL DEFAULT 'dev/update-#' COMMENT 'Format string for version name. # is version number, $ is commit number (if available).',
  `last_version_number` INT NOT NULL DEFAULT 0 COMMENT 'The last version number. This is incremented when a new build is generated for this branch.',
  `current_dist_id` INT NULL COMMENT 'The current distribution in fso_updates.',
  `addon_id` INT NULL COMMENT '(Optional) The addon to merge into the downloaded binary.',
  `base_build_url` VARCHAR(256) NOT NULL COMMENT 'URL for client binary to base updates off of. If \"teamcity\" is enabled, the client AND server binary is found within the grouped artifacts zip this link points to.',
  `base_server_build_url` VARCHAR(256) NULL COMMENT '(Optional) URL for server binary. Required for zip mode, not for teamcity.',
  `build_mode` ENUM('zip', 'teamcity') NOT NULL DEFAULT 'zip' COMMENT 'The mode to use when obtaining binaries.',
  `flags` INT NULL COMMENT '1 - Disable Incremental Updates',
  PRIMARY KEY (`branch_id`),
  INDEX `branch_addon_id_idx` (`addon_id` ASC),
  CONSTRAINT `branch_addon_id`
    FOREIGN KEY (`addon_id`)
    REFERENCES `fso_update_addons` (`addon_id`)
    ON DELETE SET NULL
    ON UPDATE CASCADE)
COMMENT = 'Update branches for the server. Each branch points to a source to download new zips from, and can optionally point to an update addon to be merged into it. This also generates a version name.';

CREATE TABLE `fso_updates` (
  `update_id` INT NOT NULL AUTO_INCREMENT COMMENT 'The ID of this update.',
  `version_name` VARCHAR(128) NOT NULL COMMENT 'The name of this version, generated from the format in the branch.',
  `addon_id` INT NULL COMMENT 'The addon pack this update includes.',
  `branch_id` INT NOT NULL COMMENT 'The branch this update was generated off of.',
  `full_zip` VARCHAR(256) NOT NULL COMMENT 'URL for the zip file containing the full client distribution. Should be used for new users and fixing failed updates.',
  `incremental_zip` VARCHAR(256) NULL COMMENT 'A zip containing the files that were added or modified since the last update (see last_update_id)',
  `manfest_url` VARCHAR(256) NULL COMMENT 'Manifest file for the incremental zip.',
  `server_zip` VARCHAR(256) NULL COMMENT 'URL to a zip containing the server distribution. Downloaded and applied by the Watchdog on server restart. (may also be used for rollbacks)',
  `last_update_id` INT NULL COMMENT 'The update that the incremental update was created from.',
  `flags` INT NOT NULL DEFAULT 0 COMMENT '1 - db-init required\n2 - force non-incremental\n4 - incremental on protected\n8 - rolled back',
  `date` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'The date the update was generated at.',
  `publish_date` DATETIME NULL COMMENT 'The date the update was published at.',
  `deploy_after` DATETIME NULL COMMENT '(Optional) The time after which to deploy this update to the server on restart. When an entry with this is set and the server shuts down, it starts the update process and sets this to NULL.',
  PRIMARY KEY (`update_id`),
  INDEX `fso_updates_addon_idx` (`addon_id` ASC),
  INDEX `fso_updates_branch_fk_idx` (`branch_id` ASC),
  CONSTRAINT `fso_updates_addon_fk`
    FOREIGN KEY (`addon_id`)
    REFERENCES `fso_update_addons` (`addon_id`)
    ON DELETE SET NULL
    ON UPDATE CASCADE,
  CONSTRAINT `fso_updates_branch_fk`
    FOREIGN KEY (`branch_id`)
    REFERENCES `fso_update_branch` (`branch_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
COMMENT = 'Updates generated by the server for branches. Should link to all published assets, and track incremental update paths. When deploy_after is set, the update will become the main update for that branch after the time elapses (on server restart).';

ALTER TABLE `fso_updates` 
ADD INDEX `fso_updates_last_fk_idx` (`last_update_id` ASC);
ALTER TABLE `fso_updates` 
ADD CONSTRAINT `fso_updates_last_fk`
  FOREIGN KEY (`last_update_id`)
  REFERENCES `fso_updates` (`update_id`)
  ON DELETE SET NULL
  ON UPDATE CASCADE;

ALTER TABLE `fso_update_branch` 
CHANGE COLUMN `flags` `flags` INT(11) NOT NULL COMMENT '1 - Disable Incremental Updates' ;

ALTER TABLE `fso_update_branch` 
ADD COLUMN `branch_name` VARCHAR(128) NOT NULL DEFAULT 'dev' AFTER `branch_id`;

ALTER TABLE `fso_updates` 
CHANGE COLUMN `full_zip` `full_zip` VARCHAR(256) NULL DEFAULT NULL COMMENT 'URL for the zip file containing the full client distribution. Should be used for new users and fixing failed updates.' ,
CHANGE COLUMN `manfest_url` `manifest_url` VARCHAR(256) NULL DEFAULT NULL COMMENT 'Manifest file for the incremental zip.' ;

ALTER TABLE `fso_update_branch` 
ADD COLUMN `minor_version_number` INT NOT NULL DEFAULT 0 AFTER `last_version_number`;

ALTER TABLE `fso_shards` 
ADD COLUMN `update_id` INT NULL DEFAULT NULL AFTER `version_number`,
ADD INDEX `fso_shard_update_id_idx` (`update_id` ASC);
ALTER TABLE `fso_shards` 
ADD CONSTRAINT `fso_shard_update_id`
  FOREIGN KEY (`update_id`)
  REFERENCES `fso_updates` (`update_id`)
  ON DELETE SET NULL
  ON UPDATE CASCADE;

  ALTER TABLE `fso_hosts` 
ADD COLUMN `update_id` INT NULL DEFAULT NULL AFTER `shard_id`,
ADD INDEX `FK_fso_host_update_id_idx` (`update_id` ASC);
ALTER TABLE `fso_hosts` 
ADD CONSTRAINT `FK_fso_host_update_id`
  FOREIGN KEY (`update_id`)
  REFERENCES `fso_updates` (`update_id`)
  ON DELETE SET NULL
  ON UPDATE CASCADE;